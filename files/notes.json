{ "notes": [
    { "note_name": "round_note", "note_value":"<br />Rounding is done according to the \"rounding[3:0]\" parameter, which can be one of:<div class='desc_note'>    (_MM_FROUND_TO_NEAREST_INT |_MM_FROUND_NO_EXC) // round to nearest, and suppress exceptions\n    (_MM_FROUND_TO_NEG_INF |_MM_FROUND_NO_EXC)     // round down, and suppress exceptions\n    (_MM_FROUND_TO_POS_INF |_MM_FROUND_NO_EXC)     // round up, and suppress exceptions\n    (_MM_FROUND_TO_ZERO |_MM_FROUND_NO_EXC)        // truncate, and suppress exceptions\n    _MM_FROUND_CUR_DIRECTION // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</div>"},
    { "note_name": "sae_note", "note_value":"<br />Exceptions can be suppressed by passing \"_MM_FROUND_NO_EXC\" in the \"sae\" parameter."},
    { "note_name": "round_imm_note", "note_value":"<br />Rounding is done according to the \"imm8[2:0]\" parameter, which can be one of:<div class='desc_note'>    _MM_FROUND_TO_NEAREST_INT // round to nearest\n    _MM_FROUND_TO_NEG_INF     // round down\n    _MM_FROUND_TO_POS_INF     // round up\n    _MM_FROUND_TO_ZERO        // truncate\n    _MM_FROUND_CUR_DIRECTION  // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</div>"},
    { "note_name": "strcmp_note", "note_value":"<br />\"imm\" can be a combination of:<div class='desc_note'>    _SIDD_UBYTE_OPS                // unsigned 8-bit characters\n    _SIDD_UWORD_OPS                // unsigned 16-bit characters\n    _SIDD_SBYTE_OPS                // signed 8-bit characters\n    _SIDD_SWORD_OPS                // signed 16-bit characters\n    _SIDD_CMP_EQUAL_ANY            // compare equal any\n    _SIDD_CMP_RANGES               // compare ranges\n    _SIDD_CMP_EQUAL_EACH           // compare equal each\n    _SIDD_CMP_EQUAL_ORDERED        // compare equal ordered\n    _SIDD_NEGATIVE_POLARITY        // negate results\n    _SIDD_MASKED_NEGATIVE_POLARITY // negate results only before end of string\n    _SIDD_LEAST_SIGNIFICANT        // index only: return last significant bit\n    _SIDD_MOST_SIGNIFICANT         // index only: return most significant bit\n    _SIDD_BIT_MASK                 // mask only: return bit mask\n    _SIDD_UNIT_MASK                // mask only: return byte/word mask</div>"},
    { "note_name": "getmant_note", "note_value":"<br />The mantissa is normalized to the interval specified by \"interv\", which can take the following values:<div class='desc_note'>    _MM_MANT_NORM_1_2     // interval [1, 2)\n    _MM_MANT_NORM_p5_2    // interval [0.5, 2)\n    _MM_MANT_NORM_p5_1    // interval [0.5, 1)\n    _MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5)</div>The sign is determined by \"sc\" which can take the following values:<div class='desc_note'>    _MM_MANT_SIGN_src     // sign = sign(src)\n    _MM_MANT_SIGN_zero    // sign = 0\n    _MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1</div>"},
    { "note_name": "fpclass_note", "note_value":"<br />\"imm\" can be a combination of:<div class='desc_note'>    0x01 // QNaN\n    0x02 // Positive Zero\n    0x04 // Negative Zero\n    0x08 // Positive Infinity\n    0x10 // Negative Infinity\n    0x20 // Denormal\n    0x40 // Negative\n    0x80 // SNaN</div>"},
    { "note_name": "max_float_note", "note_value":"<br />\"dst\" is not following IEEE 754 maximum when inputs are nan or signed-zero values."},
    { "note_name": "min_float_note", "note_value":"<br />\"dst\" is not following IEEE 754 minimum when inputs are nan or signed-zero values."}
]}